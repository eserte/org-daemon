#!/usr/bin/perl -w
# -*- perl -*-

#
# Author: Slaven Rezic
#
# Copyright (C) 2017 Slaven Rezic. All rights reserved.
# This program is free software; you can redistribute it and/or
# modify it under the same terms as Perl itself.
#
# Mail: slaven@rezic.de
# WWW:  http://www.rezic.de/eserte/
#

use strict;
use lib "/home/e/eserte/src/CPAN/App-orgdaemon/bin", "/mnt/cvrsnica/home/e/eserte/src/CPAN/App-orgdaemon/bin", "$ENV{HOME}/src/CPAN/App-orgdaemon/bin";
require "org-daemon";
use Digest::MD5 'md5_base64';
use Encode 'encode_utf8';
use POSIX 'strftime', 'ceil';
use File::Copy 'cp';
use Time::Local 'timelocal';
use Getopt::Long;

my @todo_files;
my $out_ics = "/home/eserte/trash/htdocs/TODO.ics";

GetOptions(
    'todo-file=s@' => \@todo_files,
    "ics-file=s"   => \$out_ics,
)
    or die "usage: $0 [--todo-file path ...] [--ics-file path]\n";

if (!@todo_files) {
    @todo_files = "/mnt/cvrsnica/home/e/eserte/doc/misc/TODO";
}

my %old_events;
if (-e $out_ics) {
    cp $out_ics, "$out_ics.bak";

    open my $fh, $out_ics or die "Can't open $out_ics: $!";
    my $current_event;
    my $current_uid;
    my $in_event;
    my $in_alarm;
    while(<$fh>) {
	if (/^BEGIN:VEVENT$/) {
	    $current_event = $_;
	    $in_event = 1;
	} elsif (/^END:VEVENT$/) {
	    $current_event .= $_;
	    if (!$current_uid) {
		warn "Strange: VEVENT without UID, ignoring...";
	    } else {
		$old_events{$current_uid} = $current_event;
	    }
	    undef $current_event;
	    undef $current_uid;
	    $in_event = 0;
	} elsif ($in_event) {
	    if (/^BEGIN:VALARM$/) {
		$in_alarm = 1;
	    } elsif (/^END:VALARM$/) {
		$in_alarm = 0;
	    } elsif (!$in_alarm && /^UID:(.*)$/) {
		if (defined $current_uid) {
		    warn "Strange: multiple UIDs defined, choosing later one...";
		}
		$current_uid = $1;
	    }
	    $current_event .= $_;
	}
    }
}

open my $ofh, ">", "$out_ics~" or die $!;
chmod 0644, "$out_ics~" or die $!; # XXX should reuse mode of existing $out_ics
binmode $ofh, ':encoding(utf-8)';
print $ofh <<EOF;
BEGIN:VCALENDAR
VERSION:2.0
CALSCALE:GREGORIAN
PRODID:-//Slaven Rezic//NONSGML rezic.de org2ical 0.03//EN
EOF

for my $todo_file (@todo_files) {
    my $todo_mtime = (stat($todo_file))[9];
    my @todo_dates = App::orgdaemon::find_dates_in_org_file($todo_file, include_timeless => 1, time_fallback => '00:00');
    for my $todo_date (reverse @todo_dates) {
	if ($todo_date->{text} !~ m{:(homecomputer|workcomputer|ignoreics):}) { # XXX tag list to ignore should be only configurable
	    my $uid = md5_base64(encode_utf8($todo_date->id)) . '@rezic.de';
	    my $dtstamp = strftime "%Y%m%dT%H%M%SZ", gmtime $todo_mtime;
	    #my $dtstart = $todo_date->start_is_timeless ? strftime("DTSTART;VALUE=DATE:%Y%m%d", localtime $todo_date->{epoch}) : strftime("DTSTART:%Y%m%dT%H%M%SZ", gmtime $todo_date->{epoch});
	    my $dtstart = $todo_date->start_is_timeless ? strftime("DTSTART;VALUE=DATE:%Y%m%d", localtime $todo_date->{epoch}) : strftime("DTSTART:%Y%m%dT%H%M%S", localtime $todo_date->{epoch});
	    my $dtend;
	    if ($todo_date->date_end) {
		# rfc5545: If such a "VEVENT" (daily reminder) has a "DTEND" property, it MUST be specified as a DATE value also.
		#$dtend = $todo_date->end_is_timeless || $todo_date->start_is_timeless ? strftime("DTEND;VALUE=DATE:%Y%m%d", localtime($todo_date->epoch_end + 86400)) : strftime("DTEND:%Y%m%dT%H%M%SZ", gmtime $todo_date->epoch_end);
		$dtend = $todo_date->end_is_timeless || $todo_date->start_is_timeless ? strftime("DTEND;VALUE=DATE:%Y%m%d", localtime($todo_date->epoch_end + 86400)) : strftime("DTEND:%Y%m%dT%H%M%S", localtime $todo_date->epoch_end);
	    }
	    my $description = $todo_date->formatted_text; # XXX description vs. summary?
	    my $early_warning_min;
	    if (!$todo_date->start_is_timeless || $todo_date->early_warning) {
		$early_warning_min = ceil(($todo_date->{epoch} - ($todo_date->{early_warning_epoch} || 5*60)) / 60);
	    } else {
		$early_warning_min = ceil((16*3600) / 60);
	    }
	    my $trigger = "TRIGGER:-PT${early_warning_min}M";
	    $description =~ s{\s+:.*}{};
	    $description =~ s{\s+<.*>$}{};
	    $description =~ s{\s*SCHEDULED:\s*}{ };
	    $description =~ s{,}{\\,}g;
	    my $vcal = <<"EOF";
BEGIN:VEVENT
UID:$uid
$dtstart
EOF
	    if (defined $dtend) {
		$vcal .= $dtend . "\n";
	    }
	    $vcal .= <<"EOF";
CREATED:$dtstamp
DTSTAMP:$dtstamp
LAST-MODIFIED:$dtstamp
SUMMARY:$description
TRANSP:OPAQUE
EOF
	    if (defined $trigger) {
		$vcal .= <<"EOF";
BEGIN:VALARM
ACTION:DISPLAY
DESCRIPTION:Erinnerung
$trigger
UID:ALARM-$uid
END:VALARM
EOF
	    }
	    $vcal .= <<"EOF";
END:VEVENT
EOF
	    if (exists $old_events{$uid}) {
		$vcal = get_old_or_new($vcal, $old_events{$uid});
	    }
	    print $ofh $vcal;
	}
    }
}

print $ofh <<EOF;
END:VCALENDAR
EOF

close $ofh or die $!;
if (-r $out_ics) {
    require File::Compare;
    if (File::Compare::compare($out_ics, "$out_ics~") == 0) {
	warn ".ics file did not change\n";
	exit 0;
    } else {
	system 'diff', '-u', $out_ics, "$out_ics~";
    }
}
rename "$out_ics~", $out_ics or die $!;

sub get_old_or_new {
    my($new_vcal, $old_vcal) = @_;
    my($new_vcal_cmp, $old_vcal_cmp);
    for my $def (
	      [$new_vcal, \$new_vcal_cmp],
	      [$old_vcal, \$old_vcal_cmp],
	     ) {
	my($src, $destref) = @$def;
	for my $l (split /\n/, $src) {
	    if ($l !~ m{^(CREATED|DTSTAMP|LAST-MODIFIED):}) {
		$$destref .= $l;
		$$destref .= "\n";
	    }
	}
    }
    if ($new_vcal_cmp eq $old_vcal_cmp) {
	$old_vcal;
    } else {
	$new_vcal;
    }
}

__END__
